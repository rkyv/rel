<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A box that may be uninitialized."><meta name="keywords" content="rust, rustlang, rust-lang, Frame"><title>Frame in mischief - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../normalize.css"><link rel="stylesheet" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../ayu.css" disabled><link rel="stylesheet" href="../dark.css" disabled><link rel="stylesheet" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../mischief/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../mischief/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Frame</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.allocator">allocator</a></li><li><a href="#method.as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_ptr">as_ptr</a></li><li><a href="#method.assume_init">assume_init</a></li><li><a href="#method.from_raw">from_raw</a></li><li><a href="#method.from_raw_in">from_raw_in</a></li><li><a href="#method.init">init</a></li><li><a href="#method.into_framed_slice">into_framed_slice</a></li><li><a href="#method.into_raw">into_raw</a></li><li><a href="#method.into_raw_with_allocator">into_raw_with_allocator</a></li><li><a href="#method.new">new</a></li><li><a href="#method.new_in">new_in</a></li><li><a href="#method.new_unsized">new_unsized</a></li><li><a href="#method.new_unsized_in">new_unsized_in</a></li><li><a href="#method.slot">slot</a></li></ul><h3><a href="#deref-methods-MaybeUninit%3CT%3E">Methods from Deref&lt;Target=MaybeUninit&lt;T&gt;&gt;</a></h3><ul class="block"><li><a href="#method.as_bytes">as_bytes</a></li><li><a href="#method.as_bytes_mut">as_bytes_mut</a></li><li><a href="#method.as_mut_ptr-1">as_mut_ptr</a></li><li><a href="#method.as_ptr-1">as_ptr</a></li><li><a href="#method.assume_init_drop">assume_init_drop</a></li><li><a href="#method.assume_init_mut">assume_init_mut</a></li><li><a href="#method.assume_init_read">assume_init_read</a></li><li><a href="#method.assume_init_ref">assume_init_ref</a></li><li><a href="#method.write">write</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Default-for-Frame%3CT%2C%20A%3E">Default</a></li><li><a href="#impl-Deref-for-Frame%3CT%2C%20A%3E">Deref</a></li><li><a href="#impl-DerefMut-for-Frame%3CT%2C%20A%3E">DerefMut</a></li><li><a href="#impl-Drop-for-Frame%3CT%2C%20A%3E">Drop</a></li><li><a href="#impl-Pointer-for-Frame%3CT%2C%20A%3E">Pointer</a></li><li><a href="#impl-Within%3C%3CA%20as%20RegionalAllocator%3E%3A%3ARegion%3E-for-Frame%3CT%2C%20A%3E">Within&lt;&lt;A as RegionalAllocator&gt;::Region&gt;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-Frame%3CT%2C%20A%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Frame%3CT%2C%20A%3E">!Send</a></li><li><a href="#impl-Sync-for-Frame%3CT%2C%20A%3E">!Sync</a></li><li><a href="#impl-Unpin-for-Frame%3CT%2C%20A%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Frame%3CT%2C%20A%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-Frame%3CT%2C%20A%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-Frame%3CT%2C%20A%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-Frame%3CT%2C%20A%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-Frame%3CT%2C%20A%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-Frame%3CT%2C%20A%3E">Into&lt;U&gt;</a></li><li><a href="#impl-Pointee-for-Frame%3CT%2C%20A%3E">Pointee</a></li><li><a href="#impl-TryFrom%3CU%3E-for-Frame%3CT%2C%20A%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-Frame%3CT%2C%20A%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In mischief</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Struct <a href="index.html">mischief</a>::<wbr><a class="struct" href="#">Frame</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/mischief/frame.rs.html#23-32">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="item-decl"><pre class="rust struct"><code>pub struct Frame&lt;T:&nbsp;<a class="trait" href="../ptr_meta/trait.Pointee.html" title="trait ptr_meta::Pointee">Pointee</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>, A:&nbsp;<a class="trait" href="../heresy/alloc/trait.Allocator.html" title="trait heresy::alloc::Allocator">Allocator</a>&nbsp;=&nbsp;<a class="struct" href="../heresy/alloc/struct.Global.html" title="struct heresy::alloc::Global">Global</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T::<a class="associatedtype" href="../ptr_meta/trait.Pointee.html#associatedtype.Metadata" title="type ptr_meta::Pointee::Metadata">Metadata</a>: <a class="trait" href="trait.Metadata.html" title="trait mischief::Metadata">Metadata</a>&lt;T&gt;,</span>{ /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A box that may be uninitialized.</p>
<p>Frames have the same memory layouts as <a href="../heresy/boxed/struct.Box.html"><code>Boxes</code></a>.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#49-176">source</a><a href="#impl-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T:&nbsp;<a class="trait" href="../ptr_meta/trait.Pointee.html" title="trait ptr_meta::Pointee">Pointee</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>, A:&nbsp;<a class="trait" href="../heresy/alloc/trait.Allocator.html" title="trait heresy::alloc::Allocator">Allocator</a>&gt; <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, A&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T::<a class="associatedtype" href="../ptr_meta/trait.Pointee.html#associatedtype.Metadata" title="type ptr_meta::Pointee::Metadata">Metadata</a>: <a class="trait" href="trait.Metadata.html" title="trait mischief::Metadata">Metadata</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.allocator" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#58-60">source</a><h4 class="code-header">pub fn <a href="#method.allocator" class="fnname">allocator</a>(f: <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.reference.html">&amp;</a>Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.reference.html">&amp;</a>A</h4></section></summary><div class="docblock"><p>Returns a reference to the underlying allocator.</p>
<p>Note: this is an associated function, which means that you have to call
it as <code>Frame::allocator(&amp;f)</code> instead of <code>f.allocator()</code>. This is so that
there is no conflict with a method on the inner type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ptr" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#63-65">source</a><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>Returns a pointer to the underlying memory.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_ptr" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#68-70">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>Returns a mutable pointer to the underlying memory.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.assume_init" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#89-93">source</a><h4 class="code-header">pub unsafe fn <a href="#method.assume_init" class="fnname">assume_init</a>(self) -&gt; <a class="struct" href="../heresy/boxed/struct.Box.html" title="struct heresy::boxed::Box">Box</a>&lt;T, A&gt;</h4></section></summary><div class="docblock"><p>Converts to <code>Box&lt;T, A&gt;</code>.</p>
<p>This does not move the value pointed to by the frame.</p>
<h5 id="safety"><a href="#safety">Safety</a></h5>
<p>The contents of the frame must be initialized. Calling this when the
content is not yet initialized causes immediate undefined behavior.</p>
<p>Additionally, most types have additional invariants beyond merely being
considered initialized at the type level. For example, a <code>1</code>-initialized
<code>Vec&lt;T&gt;</code> is considered initialized (under the current implementation;
this does not constitute a stable guarantee) because the only
requirement the compiler knows about it is that the data pointer must be
non-null. Creating such a <code>Vec&lt;T&gt;</code> does not cause <em>immediate</em> undefined
behavior, but will cause undefined behavior with most safe operations
(including dropping it).</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_raw_in" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#106-112">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_raw_in" class="fnname">from_raw_in</a>(raw: <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.pointer.html">*mut T</a>, alloc: A) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a frame from a raw pointer in the given allocator.</p>
<p>After calling this function, the raw pointer is owned by the resulting
<code>Frame</code>. Specifically, the <code>Frame</code> destructor will free the allocated
memory. For this to be safe, the memory must have been allocated in
accordance with the memory layout used by <code>Frame</code>.</p>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<p><code>raw</code> must be non-null and allocated by <code>alloc</code> according to the memory
layout used by <code>Frame</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_raw_with_allocator" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#129-135">source</a><h4 class="code-header">pub fn <a href="#method.into_raw_with_allocator" class="fnname">into_raw_with_allocator</a>(f: Self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.pointer.html">*mut T</a>, A)</h4></section></summary><div class="docblock"><p>Consumes the <code>Frame</code>, returning a raw pointer and the allocator.</p>
<p>The pointer will be properly aligned and non-null.</p>
<p>After calling this function, the caller is responsible for the memory
previously managed by the <code>Frame</code>. In particular, the caller should
properly release the memory, taking into account the memory layout used
by <code>Frame</code>. The easiest way to do this is to convert the raw pointer
back into a <code>Frame</code> with the <a href="struct.Frame.html#method.from_raw_in" title="Frame::from_raw_in"><code>Frame::from_raw_in</code></a> function, allowing
the <code>Frame</code> destructor to perform the cleanup.</p>
<p>Note: this is an associated function, which means that you have to call
it as <code>Frame::into_raw_with_allocator(f)</code> instead of
<code>f.into_raw_with_allocator()</code>. This is so that there is no conflict with
a method on the inner type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new_unsized_in" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#146-165">source</a><h4 class="code-header">pub unsafe fn <a href="#method.new_unsized_in" class="fnname">new_unsized_in</a>(metadata: T::<a class="associatedtype" href="../ptr_meta/trait.Pointee.html#associatedtype.Metadata" title="type ptr_meta::Pointee::Metadata">Metadata</a>, alloc: A) -&gt; Self</h4></section></summary><div class="docblock"><p>Allocates memory for an unsized type with the given metadata in the
given allocator.</p>
<p>This doesn’t actually allocate if the metadata provides a layout with
zero size.</p>
<h5 id="safety-2"><a href="#safety-2">Safety</a></h5>
<p><code>metadata</code> must be valid for a pointer to <code>T</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.slot" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#168-175">source</a><h4 class="code-header">pub fn <a href="#method.slot" class="fnname">slot</a>(&amp;mut self) -&gt; <a class="struct" href="struct.Slot.html" title="struct mischief::Slot">Slot</a>&lt;'_, T&gt;</h4></section></summary><div class="docblock"><p>Returns a <a href="struct.Slot.html" title="Slot"><code>Slot</code></a> of the internal contents.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Frame%3CT%2C%20A%3E-1" class="impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#178-208">source</a><a href="#impl-Frame%3CT%2C%20A%3E-1" class="anchor"></a><h3 class="code-header">impl&lt;T, A:&nbsp;<a class="trait" href="../heresy/alloc/trait.Allocator.html" title="trait heresy::alloc::Allocator">Allocator</a>&gt; <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, A&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_framed_slice" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#182-188">source</a><h4 class="code-header">pub fn <a href="#method.into_framed_slice" class="fnname">into_framed_slice</a>(framed: Self) -&gt; <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.slice.html">[T]</a>, A&gt;</h4></section></summary><div class="docblock"><p>Converts a <code>Frame&lt;T&gt;</code> into a <code>Frame&lt;[T]&gt;</code>.</p>
<p>This conversion does not allocate on the heap and happens in place.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new_in" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#193-196">source</a><h4 class="code-header">pub fn <a href="#method.new_in" class="fnname">new_in</a>(alloc: A) -&gt; Self</h4></section></summary><div class="docblock"><p>Allocates memory in the given allocator.</p>
<p>This doesn’t actually allocate if <code>T</code> is zero-sized.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.init" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#203-207">source</a><h4 class="code-header">pub fn <a href="#method.init" class="fnname">init</a>(self, value: T) -&gt; <a class="struct" href="../heresy/boxed/struct.Box.html" title="struct heresy::boxed::Box">Box</a>&lt;T, A&gt;</h4></section></summary><div class="docblock"><p>Sets the value of the underlying memory and converts the frame to a box.</p>
<p>This overwrites any previous value without dropping it, so be careful
not to use this after initializing the frame unless you want to skip
running the destructor.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Frame%3CT%2C%20Global%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#211-266">source</a><a href="#impl-Frame%3CT%2C%20Global%3E" class="anchor"></a><h3 class="code-header">impl&lt;T:&nbsp;<a class="trait" href="../ptr_meta/trait.Pointee.html" title="trait ptr_meta::Pointee">Pointee</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt; <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, <a class="struct" href="../heresy/alloc/struct.Global.html" title="struct heresy::alloc::Global">Global</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T::<a class="associatedtype" href="../ptr_meta/trait.Pointee.html#associatedtype.Metadata" title="type ptr_meta::Pointee::Metadata">Metadata</a>: <a class="trait" href="trait.Metadata.html" title="trait mischief::Metadata">Metadata</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_raw" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#229-233">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_raw" class="fnname">from_raw</a>(raw: <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.pointer.html">*mut T</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a frame from a raw pointer.</p>
<p>After calling this function, the raw pointer is owned by the resulting
<code>Frame</code>. Specifically, the <code>Frame</code> destructor will free the allocated
memory. For this to be safe, the memory must have been allocated in
accordance with the memory layout used by <code>Frame</code>.</p>
<h5 id="safety-3"><a href="#safety-3">Safety</a></h5>
<p>This function is unsafe because improper use may lead to memory
problems. For example, a double-free may occur if the function is called
twice on the same raw pointer.</p>
<p>The safety conditions are described in the memory layout section.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_raw" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#249-251">source</a><h4 class="code-header">pub fn <a href="#method.into_raw" class="fnname">into_raw</a>(f: Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>Consumes the <code>Frame</code>, returning a raw pointer.</p>
<p>The pointer will be properly aligned and non-null.</p>
<p>After calling this function, the caller is responsible for the memory
previously managed by the <code>Frame</code>. In particular, the caller should
properly release the memory, taking into account the memory layout used
by <code>Frame</code>. The easiest way to do this is to convert the raw pointer
back into a <code>Frame</code> with the <a href="struct.Frame.html#method.from_raw" title="Frame::from_raw"><code>Frame::from_raw</code></a> function, allowing the
<code>Frame</code> destructor to perform the cleanup.</p>
<p>Note: this is an associated function, which means that you have to call
it as <code>Frame::into_raw(f)</code> instead of <code>f.into_raw()</code>. This is so that
there is no conflict with a method on the inner type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new_unsized" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#261-265">source</a><h4 class="code-header">pub unsafe fn <a href="#method.new_unsized" class="fnname">new_unsized</a>(metadata: T::<a class="associatedtype" href="../ptr_meta/trait.Pointee.html#associatedtype.Metadata" title="type ptr_meta::Pointee::Metadata">Metadata</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Allocates memory for an object with the given metadata on the heap.</p>
<p>This doesn’t actually allocate if the metadata provides a layout with
zero size.</p>
<h5 id="safety-4"><a href="#safety-4">Safety</a></h5>
<p><code>metadata</code> must be valid for a pointer to <code>T</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Frame%3CT%2C%20Global%3E-1" class="impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#269-276">source</a><a href="#impl-Frame%3CT%2C%20Global%3E-1" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, <a class="struct" href="../heresy/alloc/struct.Global.html" title="struct heresy::alloc::Global">Global</a>&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#273-275">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Allocates memory on the heap.</p>
<p>This doesn’t actually allocate if <code>T</code> is zero-sized.</p>
</div></details></div></details></div><h2 id="deref-methods-MaybeUninit%3CT%3E" class="small-section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="union" href="https://doc.rust-lang.org/1.66.0/core/mem/maybe_uninit/union.MaybeUninit.html" title="union core::mem::maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;&gt;</span><a href="#deref-methods-MaybeUninit%3CT%3E" class="anchor"></a></h2><div id="deref-methods-MaybeUninit%3CT%3E-1"><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.write" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.55.0">1.55.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.0/src/core/mem/maybe_uninit.rs.html#488">source</a></span><h4 class="code-header">pub fn <a href="#method.write" class="fnname">write</a>(&amp;mut self, val: T) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class="docblock"><p>Sets the value of the <code>MaybeUninit&lt;T&gt;</code>.</p>
<p>This overwrites any previous value without dropping it, so be careful
not to use this twice unless you want to skip running the destructor.
For your convenience, this also returns a mutable reference to the
(now safely initialized) contents of <code>self</code>.</p>
<p>As the content is stored inside a <code>MaybeUninit</code>, the destructor is not
run for the inner data if the MaybeUninit leaves scope without a call to
<a href="https://doc.rust-lang.org/1.66.0/core/mem/maybe_uninit/union.MaybeUninit.html#method.assume_init"><code>assume_init</code></a>, <a href="https://doc.rust-lang.org/1.66.0/core/mem/maybe_uninit/union.MaybeUninit.html#method.assume_init_drop"><code>assume_init_drop</code></a>, or similar. Code that receives
the mutable reference returned by this function needs to keep this in
mind. The safety model of Rust regards leaks as safe, but they are
usually still undesirable. This being said, the mutable reference
behaves like any other mutable reference would, so assigning a new value
to it will drop the old content.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u8&gt;&gt;::uninit();

{
    <span class="kw">let </span>hello = x.write((<span class="kw-2">&amp;</span><span class="string">b&quot;Hello, world!&quot;</span>).to_vec());
    <span class="comment">// Setting hello does not leak prior allocations, but drops them
    </span><span class="kw-2">*</span>hello = (<span class="kw-2">&amp;</span><span class="string">b&quot;Hello&quot;</span>).to_vec();
    hello[<span class="number">0</span>] = <span class="string">&#39;h&#39; </span><span class="kw">as </span>u8;
}
<span class="comment">// x is initialized now:
</span><span class="kw">let </span>s = <span class="kw">unsafe </span>{ x.assume_init() };
<span class="macro">assert_eq!</span>(<span class="string">b&quot;hello&quot;</span>, s.as_slice());</code></pre></div>
<p>This usage of the method causes a leak:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;String&gt;::uninit();

x.write(<span class="string">&quot;Hello&quot;</span>.to_string());
<span class="comment">// This leaks the contained string:
</span>x.write(<span class="string">&quot;hello&quot;</span>.to_string());
<span class="comment">// x is initialized now:
</span><span class="kw">let </span>s = <span class="kw">unsafe </span>{ x.assume_init() };</code></pre></div>
<p>This method can be used to avoid unsafe in some cases. The example below
shows a part of an implementation of a fixed sized arena that lends out
pinned references.
With <code>write</code>, we can avoid the need to write through a raw pointer:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::pin::Pin;
<span class="kw">use </span>core::mem::MaybeUninit;

<span class="kw">struct </span>PinArena&lt;T&gt; {
    memory: Box&lt;[MaybeUninit&lt;T&gt;]&gt;,
    len: usize,
}

<span class="kw">impl </span>&lt;T&gt; PinArena&lt;T&gt; {
    <span class="kw">pub fn </span>capacity(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
        <span class="self">self</span>.memory.len()
    }
    <span class="kw">pub fn </span>push(<span class="kw-2">&amp;mut </span><span class="self">self</span>, val: T) -&gt; Pin&lt;<span class="kw-2">&amp;mut </span>T&gt; {
        <span class="kw">if </span><span class="self">self</span>.len &gt;= <span class="self">self</span>.capacity() {
            <span class="macro">panic!</span>(<span class="string">&quot;Attempted to push to a full pin arena!&quot;</span>);
        }
        <span class="kw">let </span>ref_ = <span class="self">self</span>.memory[<span class="self">self</span>.len].write(val);
        <span class="self">self</span>.len += <span class="number">1</span>;
        <span class="kw">unsafe </span>{ Pin::new_unchecked(ref_) }
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ptr-1" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.0/src/core/mem/maybe_uninit.rs.html#528">source</a></span><h4 class="code-header">pub fn <a href="#method.as_ptr-1" class="fnname">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>Gets a pointer to the contained value. Reading from this pointer or turning it
into a reference is undefined behavior unless the <code>MaybeUninit&lt;T&gt;</code> is initialized.
Writing to memory that this pointer (non-transitively) points to is undefined behavior
(except inside an <code>UnsafeCell&lt;T&gt;</code>).</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
x.write(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// Create a reference into the `MaybeUninit&lt;T&gt;`. This is okay because we initialized it.
</span><span class="kw">let </span>x_vec = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;*</span>x.as_ptr() };
<span class="macro">assert_eq!</span>(x_vec.len(), <span class="number">3</span>);</code></pre></div>
<p><em>Incorrect</em> usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="kw">let </span>x_vec = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;*</span>x.as_ptr() };
<span class="comment">// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️</span></code></pre></div>
<p>(Notice that the rules around references to uninitialized data are not finalized yet, but
until they are, it is advisable to avoid them.)</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_ptr-1" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.0/src/core/mem/maybe_uninit.rs.html#567">source</a></span><h4 class="code-header">pub fn <a href="#method.as_mut_ptr-1" class="fnname">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>Gets a mutable pointer to the contained value. Reading from this pointer or turning it
into a reference is undefined behavior unless the <code>MaybeUninit&lt;T&gt;</code> is initialized.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
x.write(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// Create a reference into the `MaybeUninit&lt;Vec&lt;u32&gt;&gt;`.
// This is okay because we initialized it.
</span><span class="kw">let </span>x_vec = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;mut *</span>x.as_mut_ptr() };
x_vec.push(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(x_vec.len(), <span class="number">4</span>);</code></pre></div>
<p><em>Incorrect</em> usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="kw">let </span>x_vec = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;mut *</span>x.as_mut_ptr() };
<span class="comment">// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️</span></code></pre></div>
<p>(Notice that the rules around references to uninitialized data are not finalized yet, but
until they are, it is advisable to avoid them.)</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.assume_init_read" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.60.0">1.60.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.0/src/core/mem/maybe_uninit.rs.html#692">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_read" class="fnname">assume_init_read</a>(&amp;self) -&gt; T</h4></section></summary><div class="docblock"><p>Reads the value from the <code>MaybeUninit&lt;T&gt;</code> container. The resulting <code>T</code> is subject
to the usual drop handling.</p>
<p>Whenever possible, it is preferable to use <a href="https://doc.rust-lang.org/1.66.0/core/mem/maybe_uninit/union.MaybeUninit.html#method.assume_init"><code>assume_init</code></a> instead, which
prevents duplicating the content of the <code>MaybeUninit&lt;T&gt;</code>.</p>
<h5 id="safety-5"><a href="#safety-5">Safety</a></h5>
<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really is in an initialized
state. Calling this when the content is not yet fully initialized causes undefined
behavior. The <a href="#initialization-invariant">type-level documentation</a> contains more information about
this initialization invariant.</p>
<p>Moreover, similar to the <a href="https://doc.rust-lang.org/1.66.0/core/ptr/fn.read.html" title="ptr::read"><code>ptr::read</code></a> function, this function creates a
bitwise copy of the contents, regardless whether the contained type
implements the <a href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Copy.html" title="Copy"><code>Copy</code></a> trait or not. When using multiple copies of the
data (by calling <code>assume_init_read</code> multiple times, or first calling
<code>assume_init_read</code> and then <a href="https://doc.rust-lang.org/1.66.0/core/mem/maybe_uninit/union.MaybeUninit.html#method.assume_init"><code>assume_init</code></a>), it is your responsibility
to ensure that data may indeed be duplicated.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;u32&gt;::uninit();
x.write(<span class="number">13</span>);
<span class="kw">let </span>x1 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="comment">// `u32` is `Copy`, so we may read multiple times.
</span><span class="kw">let </span>x2 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="macro">assert_eq!</span>(x1, x2);

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;<span class="prelude-ty">Option</span>&lt;Vec&lt;u32&gt;&gt;&gt;::uninit();
x.write(<span class="prelude-val">None</span>);
<span class="kw">let </span>x1 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="comment">// Duplicating a `None` value is okay, so we may read multiple times.
</span><span class="kw">let </span>x2 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="macro">assert_eq!</span>(x1, x2);</code></pre></div>
<p><em>Incorrect</em> usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;<span class="prelude-ty">Option</span>&lt;Vec&lt;u32&gt;&gt;&gt;::uninit();
x.write(<span class="prelude-val">Some</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]));
<span class="kw">let </span>x1 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="kw">let </span>x2 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="comment">// We now created two copies of the same vector, leading to a double-free ⚠️ when
// they both get dropped!</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.assume_init_drop" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.60.0">1.60.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.0/src/core/mem/maybe_uninit.rs.html#724">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_drop" class="fnname">assume_init_drop</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Drops the contained value in place.</p>
<p>If you have ownership of the <code>MaybeUninit</code>, you can also use
<a href="https://doc.rust-lang.org/1.66.0/core/mem/maybe_uninit/union.MaybeUninit.html#method.assume_init"><code>assume_init</code></a> as an alternative.</p>
<h5 id="safety-6"><a href="#safety-6">Safety</a></h5>
<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really is
in an initialized state. Calling this when the content is not yet fully
initialized causes undefined behavior.</p>
<p>On top of that, all additional invariants of the type <code>T</code> must be
satisfied, as the <code>Drop</code> implementation of <code>T</code> (or its members) may
rely on this. For example, setting a <a href="../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> to an invalid but
non-null address makes it initialized (under the current implementation;
this does not constitute a stable guarantee), because the only
requirement the compiler knows about it is that the data pointer must be
non-null. Dropping such a <code>Vec&lt;T&gt;</code> however will cause undefined
behaviour.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.assume_init_ref" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.55.0">1.55.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.0/src/core/mem/maybe_uninit.rs.html#786">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_ref" class="fnname">assume_init_ref</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class="docblock"><p>Gets a shared reference to the contained value.</p>
<p>This can be useful when we want to access a <code>MaybeUninit</code> that has been
initialized but don’t have ownership of the <code>MaybeUninit</code> (preventing the use
of <code>.assume_init()</code>).</p>
<h5 id="safety-7"><a href="#safety-7">Safety</a></h5>
<p>Calling this when the content is not yet fully initialized causes undefined
behavior: it is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really
is in an initialized state.</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5><h6 id="correct-usage-of-this-method"><a href="#correct-usage-of-this-method">Correct usage of this method:</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="comment">// Initialize `x`:
</span>x.write(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="comment">// Now that our `MaybeUninit&lt;_&gt;` is known to be initialized, it is okay to
// create a shared reference to it:
</span><span class="kw">let </span>x: <span class="kw-2">&amp;</span>Vec&lt;u32&gt; = <span class="kw">unsafe </span>{
    <span class="comment">// SAFETY: `x` has been initialized.
    </span>x.assume_init_ref()
};
<span class="macro">assert_eq!</span>(x, <span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre></div>
<h6 id="incorrect-usages-of-this-method"><a href="#incorrect-usages-of-this-method"><em>Incorrect</em> usages of this method:</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="kw">let </span>x_vec: <span class="kw-2">&amp;</span>Vec&lt;u32&gt; = <span class="kw">unsafe </span>{ x.assume_init_ref() };
<span class="comment">// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️</span></code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{cell::Cell, mem::MaybeUninit};

<span class="kw">let </span>b = MaybeUninit::&lt;Cell&lt;bool&gt;&gt;::uninit();
<span class="comment">// Initialize the `MaybeUninit` using `Cell::set`:
</span><span class="kw">unsafe </span>{
    b.assume_init_ref().set(<span class="bool-val">true</span>);
   <span class="comment">// ^^^^^^^^^^^^^^^
   // Reference to an uninitialized `Cell&lt;bool&gt;`: UB!
</span>}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.assume_init_mut" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.55.0">1.55.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.0/src/core/mem/maybe_uninit.rs.html#903">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_mut" class="fnname">assume_init_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class="docblock"><p>Gets a mutable (unique) reference to the contained value.</p>
<p>This can be useful when we want to access a <code>MaybeUninit</code> that has been
initialized but don’t have ownership of the <code>MaybeUninit</code> (preventing the use
of <code>.assume_init()</code>).</p>
<h5 id="safety-8"><a href="#safety-8">Safety</a></h5>
<p>Calling this when the content is not yet fully initialized causes undefined
behavior: it is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really
is in an initialized state. For instance, <code>.assume_init_mut()</code> cannot be used to
initialize a <code>MaybeUninit</code>.</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5><h6 id="correct-usage-of-this-method-1"><a href="#correct-usage-of-this-method-1">Correct usage of this method:</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="doccomment">/// Initializes *all* the bytes of the input buffer.
    </span><span class="kw">fn </span>initialize_buffer(buf: <span class="kw-2">*mut </span>[u8; <span class="number">1024</span>]);
}

<span class="kw">let </span><span class="kw-2">mut </span>buf = MaybeUninit::&lt;[u8; <span class="number">1024</span>]&gt;::uninit();

<span class="comment">// Initialize `buf`:
</span><span class="kw">unsafe </span>{ initialize_buffer(buf.as_mut_ptr()); }
<span class="comment">// Now we know that `buf` has been initialized, so we could `.assume_init()` it.
// However, using `.assume_init()` may trigger a `memcpy` of the 1024 bytes.
// To assert our buffer has been initialized without copying it, we upgrade
// the `&amp;mut MaybeUninit&lt;[u8; 1024]&gt;` to a `&amp;mut [u8; 1024]`:
</span><span class="kw">let </span>buf: <span class="kw-2">&amp;mut </span>[u8; <span class="number">1024</span>] = <span class="kw">unsafe </span>{
    <span class="comment">// SAFETY: `buf` has been initialized.
    </span>buf.assume_init_mut()
};

<span class="comment">// Now we can use `buf` as a normal slice:
</span>buf.sort_unstable();
<span class="macro">assert!</span>(
    buf.windows(<span class="number">2</span>).all(|pair| pair[<span class="number">0</span>] &lt;= pair[<span class="number">1</span>]),
    <span class="string">&quot;buffer is sorted&quot;</span>,
);</code></pre></div>
<h6 id="incorrect-usages-of-this-method-1"><a href="#incorrect-usages-of-this-method-1"><em>Incorrect</em> usages of this method:</a></h6>
<p>You cannot use <code>.assume_init_mut()</code> to initialize a value:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>b = MaybeUninit::&lt;bool&gt;::uninit();
<span class="kw">unsafe </span>{
    <span class="kw-2">*</span>b.assume_init_mut() = <span class="bool-val">true</span>;
    <span class="comment">// We have created a (mutable) reference to an uninitialized `bool`!
    // This is undefined behavior. ⚠️
</span>}</code></pre></div>
<p>For instance, you cannot <a href="../../std/io/trait.Read.html"><code>Read</code></a> into an uninitialized buffer:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{io, mem::MaybeUninit};

<span class="kw">fn </span>read_chunk (reader: <span class="kw-2">&amp;</span><span class="lifetime">&#39;_ </span><span class="kw-2">mut </span><span class="kw">dyn </span>io::Read) -&gt; io::Result&lt;[u8; <span class="number">64</span>]&gt;
{
    <span class="kw">let </span><span class="kw-2">mut </span>buffer = MaybeUninit::&lt;[u8; <span class="number">64</span>]&gt;::uninit();
    reader.read_exact(<span class="kw">unsafe </span>{ buffer.assume_init_mut() })<span class="question-mark">?</span>;
                            <span class="comment">// ^^^^^^^^^^^^^^^^^^^^^^^^
                            // (mutable) reference to uninitialized memory!
                            // This is undefined behavior.
    </span><span class="prelude-val">Ok</span>(<span class="kw">unsafe </span>{ buffer.assume_init() })
}</code></pre></div>
<p>Nor can you use direct field access to do field-by-field gradual initialization:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{mem::MaybeUninit, ptr};

<span class="kw">struct </span>Foo {
    a: u32,
    b: u8,
}

<span class="kw">let </span>foo: Foo = <span class="kw">unsafe </span>{
    <span class="kw">let </span><span class="kw-2">mut </span>foo = MaybeUninit::&lt;Foo&gt;::uninit();
    ptr::write(<span class="kw-2">&amp;mut </span>foo.assume_init_mut().a <span class="kw">as </span><span class="kw-2">*mut </span>u32, <span class="number">1337</span>);
                 <span class="comment">// ^^^^^^^^^^^^^^^^^^^^^
                 // (mutable) reference to uninitialized memory!
                 // This is undefined behavior.
    </span>ptr::write(<span class="kw-2">&amp;mut </span>foo.assume_init_mut().b <span class="kw">as </span><span class="kw-2">*mut </span>u8, <span class="number">42</span>);
                 <span class="comment">// ^^^^^^^^^^^^^^^^^^^^^
                 // (mutable) reference to uninitialized memory!
                 // This is undefined behavior.
    </span>foo.assume_init()
};</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bytes" class="method has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.0/src/core/mem/maybe_uninit.rs.html#1182">source</a><h4 class="code-header">pub fn <a href="#method.as_bytes" class="fnname">as_bytes</a>(&amp;self) -&gt; &amp;[<a class="union" href="https://doc.rust-lang.org/1.66.0/core/mem/maybe_uninit/union.MaybeUninit.html" title="union core::mem::maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.u8.html">u8</a>&gt;]</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>)</span></div></span></summary><div class="docblock"><p>Returns the contents of this <code>MaybeUninit</code> as a slice of potentially uninitialized bytes.</p>
<p>Note that even if the contents of a <code>MaybeUninit</code> have been initialized, the value may still
contain padding bytes which are left uninitialized.</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![feature(maybe_uninit_as_bytes, maybe_uninit_slice)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>val = <span class="number">0x12345678i32</span>;
<span class="kw">let </span>uninit = MaybeUninit::new(val);
<span class="kw">let </span>uninit_bytes = uninit.as_bytes();
<span class="kw">let </span>bytes = <span class="kw">unsafe </span>{ MaybeUninit::slice_assume_init_ref(uninit_bytes) };
<span class="macro">assert_eq!</span>(bytes, val.to_ne_bytes());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bytes_mut" class="method has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.0/src/core/mem/maybe_uninit.rs.html#1213">source</a><h4 class="code-header">pub fn <a href="#method.as_bytes_mut" class="fnname">as_bytes_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class="union" href="https://doc.rust-lang.org/1.66.0/core/mem/maybe_uninit/union.MaybeUninit.html" title="union core::mem::maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.u8.html">u8</a>&gt;]</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>)</span></div></span></summary><div class="docblock"><p>Returns the contents of this <code>MaybeUninit</code> as a mutable slice of potentially uninitialized
bytes.</p>
<p>Note that even if the contents of a <code>MaybeUninit</code> have been initialized, the value may still
contain padding bytes which are left uninitialized.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![feature(maybe_uninit_as_bytes)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>val = <span class="number">0x12345678i32</span>;
<span class="kw">let </span><span class="kw-2">mut </span>uninit = MaybeUninit::new(val);
<span class="kw">let </span>uninit_bytes = uninit.as_bytes_mut();
<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">&quot;little&quot;</span>) {
    uninit_bytes[<span class="number">0</span>].write(<span class="number">0xcd</span>);
} <span class="kw">else </span>{
    uninit_bytes[<span class="number">3</span>].write(<span class="number">0xcd</span>);
}
<span class="kw">let </span>val2 = <span class="kw">unsafe </span>{ uninit.assume_init() };
<span class="macro">assert_eq!</span>(val2, <span class="number">0x123456cd</span>);</code></pre></div>
</div></details></div></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Default-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#278-282">source</a><a href="#impl-Default-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a>, A:&nbsp;<a class="trait" href="../heresy/alloc/trait.Allocator.html" title="trait heresy::alloc::Allocator">Allocator</a> + <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, A&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.default" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#279-281">source</a><a href="#method.default" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.0/core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.66.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Deref-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#297-305">source</a><a href="#impl-Deref-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, A:&nbsp;<a class="trait" href="../heresy/alloc/trait.Allocator.html" title="trait heresy::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, A&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Target-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Target-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.0/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="union" href="https://doc.rust-lang.org/1.66.0/core/mem/maybe_uninit/union.MaybeUninit.html" title="union core::mem::maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#300-304">source</a><a href="#method.deref" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.0/core/ops/deref/trait.Deref.html#tymethod.deref" class="fnname">deref</a>(&amp;self) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-DerefMut-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#307-316">source</a><a href="#impl-DerefMut-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, A:&nbsp;<a class="trait" href="../heresy/alloc/trait.Allocator.html" title="trait heresy::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a> for <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, A&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#308-315">source</a><a href="#method.deref_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.0/core/ops/deref/trait.DerefMut.html#tymethod.deref_mut" class="fnname">deref_mut</a>(&amp;mut self) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></h4></section></summary><div class='docblock'>Mutably dereferences the value.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Drop-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#34-47">source</a><a href="#impl-Drop-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T:&nbsp;<a class="trait" href="../ptr_meta/trait.Pointee.html" title="trait ptr_meta::Pointee">Pointee</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>, A:&nbsp;<a class="trait" href="../heresy/alloc/trait.Allocator.html" title="trait heresy::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, A&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T::<a class="associatedtype" href="../ptr_meta/trait.Pointee.html#associatedtype.Metadata" title="type ptr_meta::Pointee::Metadata">Metadata</a>: <a class="trait" href="trait.Metadata.html" title="trait mischief::Metadata">Metadata</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#38-46">source</a><a href="#method.drop" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.0/core/ops/drop/trait.Drop.html#tymethod.drop" class="fnname">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href="https://doc.rust-lang.org/1.66.0/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Pointer-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#286-295">source</a><a href="#impl-Pointer-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T:&nbsp;<a class="trait" href="../ptr_meta/trait.Pointee.html" title="trait ptr_meta::Pointee">Pointee</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>, A:&nbsp;<a class="trait" href="../heresy/alloc/trait.Allocator.html" title="trait heresy::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="trait.Pointer.html" title="trait mischief::Pointer">Pointer</a> for <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, A&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;T as <a class="trait" href="../ptr_meta/trait.Pointee.html" title="trait ptr_meta::Pointee">Pointee</a>&gt;::<a class="associatedtype" href="../ptr_meta/trait.Pointee.html#associatedtype.Metadata" title="type ptr_meta::Pointee::Metadata">Metadata</a>: <a class="trait" href="trait.Metadata.html" title="trait mischief::Metadata">Metadata</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Target" class="anchor"></a><h4 class="code-header">type <a href="trait.Pointer.html#associatedtype.Target" class="associatedtype">Target</a> = T</h4></section></summary><div class='docblock'>The target value of this type.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.target" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#292-294">source</a><a href="#method.target" class="anchor"></a><h4 class="code-header">fn <a href="trait.Pointer.html#tymethod.target" class="fnname">target</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="trait.Pointer.html#associatedtype.Target" title="type mischief::Pointer::Target">Target</a></h4></section></summary><div class='docblock'>Returns a pointer to this type’s target.</div></details></div></details><section id="impl-Within%3C%3CA%20as%20RegionalAllocator%3E%3A%3ARegion%3E-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/mischief/frame.rs.html#320-326">source</a><a href="#impl-Within%3C%3CA%20as%20RegionalAllocator%3E%3A%3ARegion%3E-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, A&gt; <a class="trait" href="trait.Within.html" title="trait mischief::Within">Within</a>&lt;&lt;A as <a class="trait" href="trait.RegionalAllocator.html" title="trait mischief::RegionalAllocator">RegionalAllocator</a>&gt;::<a class="associatedtype" href="trait.RegionalAllocator.html#associatedtype.Region" title="type mischief::RegionalAllocator::Region">Region</a>&gt; for <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, A&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../ptr_meta/trait.Pointee.html" title="trait ptr_meta::Pointee">Pointee</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;T as <a class="trait" href="../ptr_meta/trait.Pointee.html" title="trait ptr_meta::Pointee">Pointee</a>&gt;::<a class="associatedtype" href="../ptr_meta/trait.Pointee.html#associatedtype.Metadata" title="type ptr_meta::Pointee::Metadata">Metadata</a>: <a class="trait" href="trait.Metadata.html" title="trait mischief::Metadata">Metadata</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="trait.RegionalAllocator.html" title="trait mischief::RegionalAllocator">RegionalAllocator</a>,</span></h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a href="#impl-RefUnwindSafe-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>, A&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, A&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section><section id="impl-Send-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a href="#impl-Send-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, A&nbsp;=&nbsp;<a class="struct" href="../heresy/alloc/struct.Global.html" title="struct heresy::alloc::Global">Global</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, A&gt;</h3></section><section id="impl-Sync-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a href="#impl-Sync-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, A&nbsp;=&nbsp;<a class="struct" href="../heresy/alloc/struct.Global.html" title="struct heresy::alloc::Global">Global</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, A&gt;</h3></section><section id="impl-Unpin-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a href="#impl-Unpin-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>, A&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, A&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</span></h3></section><section id="impl-UnwindSafe-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a href="#impl-UnwindSafe-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T:&nbsp;?<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>, A&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Frame.html" title="struct mischief::Frame">Frame</a>&lt;T, A&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.0/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.0/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.66.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.66.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.0/src/core/borrow.rs.html#211">source</a><a href="#impl-Borrow%3CT%3E-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.0/src/core/borrow.rs.html#213">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.66.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.0/src/core/borrow.rs.html#220">source</a><a href="#impl-BorrowMut%3CT%3E-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.66.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.0/src/core/borrow.rs.html#221">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.66.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.0/src/core/convert/mod.rs.html#733">source</a><a href="#impl-From%3CT%3E-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.0/src/core/convert/mod.rs.html#736">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.0/src/core/convert/mod.rs.html#717">source</a><a href="#impl-Into%3CU%3E-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.0/src/core/convert/mod.rs.html#725">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.66.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Pointee-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/ptr_meta/lib.rs.html#114">source</a><a href="#impl-Pointee-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../ptr_meta/trait.Pointee.html" title="trait ptr_meta::Pointee">Pointee</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Metadata" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Metadata" class="anchor"></a><h4 class="code-header">type <a href="../ptr_meta/trait.Pointee.html#associatedtype.Metadata" class="associatedtype">Metadata</a> = <a class="primitive" href="https://doc.rust-lang.org/1.66.0/std/primitive.unit.html">()</a></h4></section></summary><div class='docblock'>The type for metadata in pointers and references to <code>Self</code>.</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.0/src/core/convert/mod.rs.html#775">source</a><a href="#impl-TryFrom%3CU%3E-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.66.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.0/src/core/convert/mod.rs.html#781">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-Frame%3CT%2C%20A%3E" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.66.0/src/core/convert/mod.rs.html#760">source</a><a href="#impl-TryInto%3CU%3E-for-Frame%3CT%2C%20A%3E" class="anchor"></a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.66.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.66.0/src/core/convert/mod.rs.html#766">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.66.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.66.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.66.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.66.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="mischief" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0 (69f9c33d7 2022-12-12)" ></div></body></html>